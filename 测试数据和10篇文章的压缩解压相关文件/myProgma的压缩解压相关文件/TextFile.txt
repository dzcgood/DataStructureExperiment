#ifndef _HUFFMANNODE_H_#define _HUFFMANNODE_H_#pragma once//#include<iostream>#include"myHeap.h"#include<fstream>#include<cstdio>using namespace std;///////////////////////////////////HuffmanNode/////////////////////////////////struct HuffmanNode{char key;//int times;//string code;//HuffmanNode* leftChild, * rightChild;HuffmanNode* parent;//HuffmanNode() :leftChild(NULL), rightChild(NULL), parent(NULL){key = '\0';times = 0;code = "";}//HuffmanNode(char c,int t=0, HuffmanNode* left = NULL, HuffmanNode* right = NULL,HuffmanNode*par=NULL){key = c;times = t;leftChild = left;rightChild = right;parent = par;code = "";}//<=timesbool operator<=(HuffmanNode& R) { return times <= R.times; }//>timesbool operator>(HuffmanNode& R) { return times > R.times; }};////////////////////////////////HuffmanTree//////////////////////////////class HuffmanTree{public:HuffmanTree();//HuffmanTree~HuffmanTree() {deleteTree(root);delete[]times;delete[]codes;delete[]keys;}unsigned short *times;//int wpl;//short typeNum;//string* codes;//char* keys;//HuffmanNode* root;////HuffmanTreevoid createTree(char keys[], unsigned short w[], int n);//void mergeTree(HuffmanNode* bt1, HuffmanNode* bt2, HuffmanNode*& parent);//void encoding(string fileName);//fileNamevoid decode(string fileName);                                      //HuffmanTreehfmTree.txtvoid save(); //bool isEmpty() { return root == 0; }//wplwplvoid setWpl(HuffmanNode* root);//HuffmanTreevoid encode(HuffmanNode* root, string s);//codes[]void setCodeArray(HuffmanNode* root);//void countTimes();//huffmanvoid displayHuffman();private://HuffmanTreevoid displayHuffman(HuffmanNode* root, int ident, ofstream& out);//void deleteTree(HuffmanNode* root);};////////////////////////////////HuffmanTree/////////////////////////////////HuffmanTreeroot//voidvoid HuffmanTree::deleteTree(HuffmanNode* root){if (root == 0)return;else{deleteTree(root->leftChild);deleteTree(root->rightChild);delete root;}}//////HuffmanTree::HuffmanTree(){codes = 0;times = 0;root = 0;typeNum = 0;keys = 0;wpl = 0;}//HuffmanTree//wkeysn//voidvoid HuffmanTree::createTree(char keys[], unsigned short w[], int n){MyHeap<HuffmanNode>heap1;HuffmanNode* parent = 0, * first, * second, * work, temp;for (int i = 0; i < n; i++)//{work = new HuffmanNode();work->leftChild = NULL;//work->rightChild = NULL;work->parent = work;work->key = keys[i];work->times = w[i];heap1.Insert(*work);}//n-1for (int i = 1; i <= n - 1; i++){heap1.Remove(temp);first = temp.parent;heap1.Remove(temp);second = temp.parent;mergeTree(first, second, parent);//heap1.Insert(*parent);//}root = parent;}////bt1,bt2,parent//voidvoid HuffmanTree::mergeTree(HuffmanNode* bt1, HuffmanNode* bt2, HuffmanNode*& parent){parent = new HuffmanNode;parent->leftChild = bt1;parent->rightChild = bt2;parent->parent = parent;parent->times = bt1->times + bt2->times;parent->key = '\0';//'\0'bt1->parent = bt2->parent = parent;}//wpl//root//voidvoid HuffmanTree::setWpl(HuffmanNode*root){if (!root)return;else{if (root->leftChild != 0 || root->rightChild != 0)//wpl += root->times;//wplsetWpl(root->leftChild);setWpl(root->rightChild);}}//HuffmanTree'0'1//HuffmanTreeroots//voidvoid HuffmanTree::encode(HuffmanNode* root, string s){if (root == NULL)return;////s'0's = s + '0';if (root->leftChild != NULL){root->leftChild->code = s;}encode(root->leftChild, s);////1s[s.size() - 1] = '1';if (root->rightChild != NULL)root->rightChild->code = s;encode(root->rightChild, s);//}//codes[]//root//voidvoid HuffmanTree::setCodeArray(HuffmanNode* root){if (root == 0)return;if (root->leftChild == 0 && root->rightChild == 0){for (int i = 0; i < typeNum; i++)//if (keys[i] == root->key)codes[i] = root->code;}setCodeArray(root->leftChild);setCodeArray(root->rightChild);}//HuffmanTreehfmTree.txt//          ////voidvoid HuffmanTree::save(){ofstream out("hfmTree.txt", ios::binary);if (!out){cout << "" << endl;return;}//out.write((char*)&typeNum, sizeof(short));//for (int i = 0; i < typeNum; i++){out.write((char*)&keys[i], sizeof(keys[i]));out.write((char*)&times[i], sizeof(times[i]));}out.close();}//CodeFile.txt////voidvoid HuffmanTree::encoding(string fileName){//char* binaryCode = new char[wpl];//\0memset(binaryCode, '\0', sizeof(binaryCode));ofstream out("CodeFile.txt", ios::binary);ifstream in(fileName, ios::in);if (!in || !out){cout << "" << endl;return;}char c;////int flag = 0;while (in.peek() != EOF){c = in.get();//ccodesfor(int u=0;u<typeNum;u++){if (keys[u] == c)//{for (int i = 0; i < codes[u].length(); i++)//cbinaryCode{binaryCode[flag] = codes[u][i];flag++;}break;}}}out.write((char*)&flag, sizeof(flag));////flagshort num = 0;int i = 0;for (i = 0; i < flag-flag%8; i++){if(binaryCode[i]=='1')num += pow(2, 7 - i % 8);if ((i + 1) % 8 == 0){unsigned char c = num;//num255unsigned charout.write((char*)&c,sizeof(c));num = 0;}}int temp = 128;for (i = flag-flag%8; i < flag ; i++){num += (binaryCode[i]-'0')*temp;temp = temp / 2;}unsigned char numToWrite = num;out.write((char*)&numToWrite, sizeof(numToWrite));out.close();in.close();cout << "CodeFile.txt" << endl;}//CodeFile.txt////voidvoid HuffmanTree::decode(string fileName){ifstream in(fileName, ios::binary);if (!in){cout << "!" << endl;return;}char* binaryCode = new char[wpl];memset(binaryCode, '\0', sizeof(binaryCode));short num;//unsigned char c;int flag = 0;//int WPL;in.read((char*)&WPL, sizeof(WPL));//binaryCodefor (int i = 1; i <= WPL / 8; i++){in.read((char*)&c, sizeof(c));num = c;int temp = 128;for (int i = 0; i < 8; i++, flag++){if (num >= temp){num = num - temp;binaryCode[flag] = '1';}elsebinaryCode[flag] = '0';temp = temp / 2;}}//8if (WPL % 8 != 0){in.read((char*)&c, sizeof(c));num = c;int temp = 128;for (int i = 0; i < WPL % 8; i++, flag++){if (num >= temp){num = num - temp;binaryCode[flag] = '1';}elsebinaryCode[flag] = '0';temp = temp / 2;}}//HuffmanNode* current = root;ofstream out("TextFile.txt", ios::out);if (!out){cout << "" << endl;return;}for (int i = 0; i < WPL; i++){char c = binaryCode[i];if (c == '0'){current = current->leftChild;}else if (c == '1'){current = current->rightChild;}if (current->leftChild == NULL && current->rightChild == NULL){c = current->key;out.write((char*)&c, sizeof(char));current = root;//}}in.close();out.close();cout << "TextFile";cout << endl << endl;}//huffman////voidvoid HuffmanTree::displayHuffman(){ofstream out("TreePrin.txt", ios::out);if (!out){cout << "" << endl;return;}displayHuffman(root, 0, out);out.close();}//HuffmanTree//rootidentint vec_left[100] = { 0 };void HuffmanTree::displayHuffman(HuffmanNode* root, int ident,ofstream&out){if (ident > 0){for (int i = 0; i < ident - 1; ++i){cout<<(vec_left[i] ? "   " : "    ");//out << (vec_left[i] ? "   " : "    ");//}cout<<(vec_left[ident - 1] ? " " : " ");out << (vec_left[ident - 1] ? " " : " ");}if (!root){cout<<"(null)"<<endl;out << "(null)"<<endl;return;}if (root->key == '\0')//\0{cout << "\\0" << endl;out << "\\0" << endl;}else{cout << root->key << endl;out << root->key << endl;}if (!root->leftChild && !root->rightChild){return;}vec_left[ident] = 1;displayHuffman(root->leftChild, ident + 1,out);//vec_left[ident] = 0;displayHuffman(root->rightChild, ident + 1,out);//}////////void HuffmanTree::countTimes(){int counts[128];memset(counts, 0, sizeof(counts));cout << "" << endl;string fileName;cin >> fileName;ifstream in(fileName, ios::in);if (!in){cout << "";return;}char c;while (in.peek() != EOF){c=in.get(); //counts[c - '\0']++;}int num = 0;//for (int i = 31; i <128; i++){if (counts[i] != 0){c = i - 0;cout << c << " " << counts[i] << " " << endl;num++;}}cout << "" << num << endl;cout << "()" << endl;in.close();}#endif//myHeap.h//  //  //2020.12.25#ifndef _MYHEAP_H_#define _MYHEAP_H_#pragma once#include<iostream>using namespace std;//130const int DefaultSize =130;////////////////////////////////myHeap//////////////////////////////template<class T>class MyHeap{//heapT* heap;//int currentSize;//int maxHeapSize;public://MyHeap(int sz = DefaultSize);//MyHeap(T arr[], int n);//~MyHeap() { delete[]heap; }//bool Insert(T& x);//bool Remove(T& x);//bool IsEmpty()const{return currentSize == 0;}//bool IsFull()const{return currentSize == maxHeapSize;}//void MakeEmpty(){currentSize = 0;}private://void siftDown(int start, int m);//void siftUp(int start);};/////////////////////////////////myHeap////////////////////////////////maxSize////sz//template<class T>MyHeap<T>::MyHeap(int sz){maxHeapSize = (DefaultSize < sz) ? sz : DefaultSize;heap = new T[maxHeapSize];//currentSize = 0;}////arrn//template <class T>MyHeap<T>::MyHeap(T arr[], int n){maxHeapSize = (DefaultSize < n) ? n : DefaultSize;heap = new T[maxHeapSize];//for (int i = 0; i < n; i++){heap[i] = arr[i];}//currentSize = n;int currentPos = (currentSize - 2) / 2;//while (currentPos >= 0){//currentPoscurrentSizesiftDown(currentPos, currentSize - 1); currentPos--;  }}//x//x//truefalsetemplate <class T>bool MyHeap<T>::Insert(T& x){//if (currentSize == maxHeapSize){ cout << "" << endl;return false;}//heap[currentSize] = x;siftUp(currentSize);   //currentSize++;   //1return true;}////x//truefalsetemplate <class T>bool MyHeap<T>::Remove(T& x){//if (!currentSize){ cout << "" << endl;return false;}//x = heap[0]; // heap[0] = heap[currentSize - 1]; //currentSize--;                   //1siftDown(0, currentSize - 1); //return true;}////startm//template<class T>void MyHeap<T>::siftDown(int start, int m){int i = start, j = 2 * i + 1;T temp = heap[i];while (j <= m){//if (j<m && heap[j]>heap[j + 1])j++;if (temp <= heap[j])break;else{heap[i] = heap[j];i = j;j = 2 * j + 1;//}}heap[i] = temp;} ////start//template<class T>void MyHeap<T>::siftUp(int start){//start0int j = start, i = (j - 1) / 2;//ijT temp = heap[j];while (j > 0){if (heap[i] <= temp)break;else{heap[j] = heap[i];j = i;i = (i - 1) / 2;//}}heap[j] = temp;}#endif#include<iostream>#include"HuffmanNode.H"using namespace std;void menu(){cout << "------------------" << endl;cout << "0---" << endl;cout << "1---(Initialization)" << endl;cout << "2---(Encoding)" << endl;cout << "3---(Decoding)" << endl;cout << "4---(Print)" << endl;cout << "5---(TreePrinting)" << endl;cout << "6---(Exit)" << endl;}////switchvoid func0(HuffmanTree &myTree);//void func1(HuffmanTree &myTree);//void func2(HuffmanTree &myTree);//void func3(HuffmanTree &myTree);//void func4(HuffmanTree &myTree);//void func5(HuffmanTree &myTree);//void func6(HuffmanTree& myTree);////void(*functionPointer[7])(HuffmanTree &myTree) = { func0,func1,func2,func3,func4,func5,func6 };int main(){int input;menu();cin >> input;HuffmanTree myTree;while (true){if (input >= 0 && input <= 6){(*functionPointer[input])(myTree);//menu();//}elsecout << "" << endl;cin >> input;}return 0;}//////////////////////////////////func0-func6///////////////////////////////////HuffmanTreemyTree//voidvoid func0(HuffmanTree& myTree){myTree.countTimes();}////HuffmanTreemyTree//voidvoid func1(HuffmanTree &myTree){unsigned short num,times;char c;cout << "" << endl;cin >> num;myTree.keys = new char[num+1];myTree.times = new unsigned short[num];myTree.codes = new string[num];for (int i = 0; i < num; i++){cout << ""<<i+1<<"" << endl;getchar();//\n\tmyTree.keys[i] = getchar();cout << "" << endl;getchar();//\n\tcin >> myTree.times[i];}myTree.typeNum = num;//myTree.createTree(myTree.keys, myTree.times, num);//myTree.setWpl(myTree.root);//wplmyTree.encode(myTree.root,"");//myTree.setCodeArray(myTree.root);myTree.save();//}////HuffmanTreemyTree//voidvoid func2(HuffmanTree &myTree){if (myTree.isEmpty()){ifstream in("hfmTree.txt", ios::binary);if (!in){cout << "" << endl;return;}//in.read((char*)&myTree.typeNum, sizeof(myTree.typeNum));myTree.keys = new char[myTree.typeNum + 1];myTree.times = new unsigned short[myTree.typeNum];myTree.codes = new string[myTree.typeNum];//for (int i = 0; i < myTree.typeNum; i++){in.read((char*)&myTree.keys[i], sizeof(myTree.keys[i]));in.read((char*)&myTree.times[i], sizeof(myTree.times[i]));}myTree.createTree(myTree.keys, myTree.times, myTree.typeNum);//myTree.setWpl(myTree.root);//wplmyTree.encode(myTree.root, "");//myTree.setCodeArray(myTree.root);myTree.save();//}//string fileName;cout << "" << endl;cin >> fileName;myTree.encoding(fileName);}////HuffmanTreemyTree//voidvoid func3(HuffmanTree &myTree){if (myTree.isEmpty()){ifstream in("hfmTree.txt", ios::binary);if (!in){cout << "" << endl;return;}//in.read((char*)&myTree.typeNum, sizeof(myTree.typeNum));//myTree.keys = new char[myTree.typeNum + 1];myTree.times = new unsigned short[myTree.typeNum];myTree.codes = new string[myTree.typeNum];//for (int i = 0; i < myTree.typeNum; i++){in.read((char*)&myTree.keys[i], sizeof(myTree.keys[i]));in.read((char*)&myTree.times[i], sizeof(myTree.times[i]));}myTree.createTree(myTree.keys, myTree.times, myTree.typeNum);//myTree.setWpl(myTree.root);//wplmyTree.encode(myTree.root, "");//myTree.setCodeArray(myTree.root);//codes[]myTree.save();//}//cout << "" << endl;string fileName;cin >> fileName;myTree.decode(fileName);}////HuffmanTreemyTree//voidvoid func4(HuffmanTree &myTree){//wplHuffmanstring fileName;cout << "" << endl;cin >> fileName;ifstream in(fileName, ios::binary);ofstream out("CodePrin.txt", ios::out);if (!in||!out){cout << "" << endl;return;}int wpl;in.read((char*)&wpl, sizeof(int));unsigned char c;int temp=0;////01for (int i = 0; i < wpl / 8; i++){in.read((char*)&c, sizeof(c));int num = c;for (int i = 8; i > 0; i--){if (c & (1 << i)){cout << "1";out << '1';}else{cout << "0";out << '0';}temp++;if (temp % 50 == 0)//50{cout << endl;out << endl;}}}//8if (wpl % 8 != 0){in.read((char*)&c, sizeof(c));int num = c;for (int i = wpl%8; i > 0; i--){if (c & (1 << i)){cout << "1";out << '1';}else{cout << "0";out << '0';}temp++;if (temp % 50 == 0)//50{cout << endl;out << endl;}}}cout << endl;}//huffman//HuffmanTreemyTree//voidvoid func5(HuffmanTree &myTree){if (myTree.isEmpty()){ifstream in("hfmTree.txt", ios::binary);if (!in){cout << "" << endl;return;}//in.read((char*)&myTree.typeNum, sizeof(myTree.typeNum));myTree.keys = new char[myTree.typeNum + 1];myTree.times = new unsigned short[myTree.typeNum];myTree.codes = new string[myTree.typeNum];//for (int i = 0; i < myTree.typeNum; i++){in.read((char*)&myTree.keys[i], sizeof(myTree.keys[i]));in.read((char*)&myTree.times[i], sizeof(myTree.times[i]));}myTree.createTree(myTree.keys, myTree.times, myTree.typeNum);//myTree.setWpl(myTree.root);//wplmyTree.encode(myTree.root, "");//myTree.setCodeArray(myTree.root);myTree.save();//myTree.displayHuffman();}elsemyTree.displayHuffman();cout << "TreePrin.txt\\0" << endl << endl;}////HuffmanTreemyTree//voidvoid func6(HuffmanTree &myTree){cout << "" << endl;exit(0);}